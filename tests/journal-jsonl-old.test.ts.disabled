/**
 * Journal Operations Test Suite
 * Implements comprehensive tests based on journal.contracts.ts
 */

import { test, expect, describe, beforeEach, afterEach } from "bun:test";
import { existsSync, writeFileSync, chmodSync } from "fs";
import { join } from "path";
import {
  saveEntry,
  readAllEntries,
  getRecentEntries,
  generateId,
  getTuskDir,
  getJournalPath,
  getJournalStats,
  searchEntries,
} from "../journal.js";
import {
  TestDataFactory,
  TestEnvironment,
  PerformanceTester,
  ErrorTester,
  TestAssertions,
  TEST_CONFIG,
} from "./setup.js";
import type { JournalEntry } from "../journal.js";

// Setup test environment
beforeEach(() => {
  TestEnvironment.setup();
});

afterEach(() => {
  TestEnvironment.cleanup();
});

describe("Journal Operations - Core Functionality", () => {
  describe("Directory Management", () => {
    test("should create .tusk directory if it doesn't exist", async () => {
      // Ensure directory doesn't exist
      TestEnvironment.cleanup();

      const tuskDir = getTuskDir();
      expect(existsSync(tuskDir)).toBe(true);
      expect(tuskDir).toContain(".tusk");
    });

    test("should return existing directory path if already exists", async () => {
      const firstCall = getTuskDir();
      const secondCall = getTuskDir();

      expect(firstCall).toBe(secondCall);
      expect(existsSync(firstCall)).toBe(true);
    });

    test("should work with custom home directory paths", async () => {
      // This test would require mocking homedir(), skipping for now
      // but important for full coverage
    });
  });

  describe("ID Generation", () => {
    test("should generate unique IDs every time", async () => {
      const ids = Array.from({ length: 1000 }, () => generateId());
      const uniqueIds = new Set(ids);

      expect(uniqueIds.size).toBe(ids.length);
    });

    test("should generate IDs with timestamp prefix", async () => {
      const id = generateId();
      const timestampPart = id.split("_")[0];

      // Should be a valid timestamp format (YYYYMMDDHHMMSS)
      expect(timestampPart).toMatch(/^\d{14}$/);

      // Should be close to current time
      const now = new Date();
      const idTime = new Date(
        parseInt(timestampPart.substr(0, 4)), // year
        parseInt(timestampPart.substr(4, 2)) - 1, // month (0-indexed)
        parseInt(timestampPart.substr(6, 2)), // day
        parseInt(timestampPart.substr(8, 2)), // hour
        parseInt(timestampPart.substr(10, 2)), // minute
        parseInt(timestampPart.substr(12, 2)) // second
      );

      const timeDiff = Math.abs(now.getTime() - idTime.getTime());
      expect(timeDiff).toBeLessThan(2000); // Within 2 seconds
    });

    test("should generate IDs with random suffix", async () => {
      const id = generateId();
      const randomPart = id.split("_")[1];

      expect(randomPart).toMatch(/^[a-z0-9]{6}$/);
      expect(randomPart.length).toBe(6);
    });

    test("should generate IDs that are sortable by creation time", async () => {
      const ids: string[] = [];

      // Generate IDs with small delays to ensure different timestamps
      for (let i = 0; i < 10; i++) {
        ids.push(generateId());
        await new Promise(resolve => setTimeout(resolve, 2));
      }

      const sortedIds = [...ids].sort();
      expect(sortedIds).toEqual(ids);
    });

    test("should handle rapid generation (1000+ IDs/second)", async () => {
      const { result, executionTime } = await PerformanceTester.measureExecution(
        async () => {
          return Array.from({ length: 1000 }, () => generateId());
        },
        100 // Should complete in under 100ms
      );

      expect(result.length).toBe(1000);
      expect(new Set(result).size).toBe(1000); // All unique
      TestAssertions.assertPerformance(executionTime, 100, "ID generation (1000 IDs)");
    });
  });

  describe("Entry Persistence", () => {
    test("should save valid journal entries to JSONL file", async () => {
      const entry = TestDataFactory.createJournalEntry();

      await saveEntry(entry);

      const journalPath = getJournalPath();
      expect(existsSync(journalPath)).toBe(true);

      const savedEntries = await readAllEntries();
      expect(savedEntries).toHaveLength(1);
      TestAssertions.assertJournalEntry(savedEntries[0], entry);
    });

    test("should append entries without overwriting existing data", async () => {
      const entries = TestDataFactory.createMultipleEntries(3);

      // Save entries one by one
      for (const entry of entries) {
        await saveEntry(entry);
      }

      const savedEntries = await readAllEntries();
      expect(savedEntries).toHaveLength(3);

      // Verify all entries are present
      entries.forEach((expected, index) => {
        TestAssertions.assertJournalEntry(savedEntries[index], expected);
      });
    });

    test("should handle concurrent writes without corruption", async () => {
      const entries = TestDataFactory.createMultipleEntries(10);

      // Save all entries concurrently
      await Promise.all(entries.map(entry => saveEntry(entry)));

      const savedEntries = await readAllEntries();
      expect(savedEntries).toHaveLength(10);

      // Verify no data corruption
      savedEntries.forEach(entry => {
        expect(entry.id).toBeDefined();
        expect(entry.type).toBe("checkpoint");
        expect(entry.description).toBeDefined();
        expect(entry.timestamp).toBeDefined();
      });
    });

    test("should validate entry structure before saving", async () => {
      const invalidEntry = { invalid: "structure" } as any;

      // This should ideally validate and throw, but current implementation doesn't
      // This test documents expected behavior for future validation implementation
      await expect(saveEntry(invalidEntry)).rejects.toThrow();
    });

    test("should handle file system permission errors", async () => {
      // Create read-only directory to simulate permission error
      const journalPath = getJournalPath();
      const entry = TestDataFactory.createJournalEntry();

      // Make parent directory read-only
      if (process.platform !== "win32") {
        chmodSync(getTuskDir(), 0o444);

        await expect(saveEntry(entry)).rejects.toThrow();

        // Restore permissions for cleanup
        chmodSync(getTuskDir(), 0o755);
      }
    });
  });

  describe("Entry Retrieval", () => {
    test("should read all entries from JSONL file", async () => {
      const entries = TestDataFactory.createMultipleEntries(5);

      // Save entries
      for (const entry of entries) {
        await saveEntry(entry);
      }

      const { result, executionTime } = await PerformanceTester.measureExecution(
        () => readAllEntries(),
        TEST_CONFIG.PERFORMANCE_THRESHOLDS.JOURNAL_OPERATION
      );

      expect(result).toHaveLength(5);
      TestAssertions.assertPerformance(
        executionTime,
        TEST_CONFIG.PERFORMANCE_THRESHOLDS.JOURNAL_OPERATION,
        "Read all entries"
      );
    });

    test("should return empty array for non-existent file", async () => {
      // Ensure no journal file exists
      TestEnvironment.resetJournal();

      const entries = await readAllEntries();
      expect(entries).toEqual([]);
    });

    test("should skip malformed JSON lines gracefully", async () => {
      const validEntries = TestDataFactory.createMultipleEntries(3);
      const corruptedContent = ErrorTester.createCorruptedJSONL(validEntries);

      // Write corrupted content directly to file
      writeFileSync(getJournalPath(), corruptedContent);

      const entries = await readAllEntries();

      // Should recover the valid entries and skip corrupted ones
      expect(entries.length).toBeLessThanOrEqual(validEntries.length);
      expect(entries.length).toBeGreaterThan(0);

      // All returned entries should be valid
      entries.forEach(entry => {
        expect(entry.id).toBeDefined();
        expect(entry.type).toBe("checkpoint");
        expect(entry.timestamp).toBeDefined();
      });
    });

    test("should handle large files (10000+ entries) efficiently", async () => {
      const largeEntrySet = TestDataFactory.createMultipleEntries(1000); // Reduced for test speed

      // Save all entries
      for (const entry of largeEntrySet) {
        await saveEntry(entry);
      }

      const { result, executionTime } = await PerformanceTester.measureExecution(
        () => readAllEntries(),
        500 // Should handle 1000 entries in under 500ms
      );

      expect(result).toHaveLength(1000);
      TestAssertions.assertPerformance(executionTime, 500, "Read large file (1000 entries)");
    });

    test("should handle empty files", async () => {
      // Create empty journal file
      writeFileSync(getJournalPath(), "");

      const entries = await readAllEntries();
      expect(entries).toEqual([]);
    });

    test("should handle files with only whitespace/newlines", async () => {
      // Create file with only whitespace
      writeFileSync(getJournalPath(), "\n\n  \n\t\n  \n");

      const entries = await readAllEntries();
      expect(entries).toEqual([]);
    });
  });

  describe("Search & Filtering", () => {
    beforeEach(async () => {
      // Setup test data with known characteristics
      const testEntries = [
        TestDataFactory.createJournalEntry({
          description: "Fixed authentication bug",
          tags: ["bug-fix", "auth"],
          project: "project-a",
          timestamp: new Date(Date.now() - 60000).toISOString(), // 1 min ago
        }),
        TestDataFactory.createJournalEntry({
          description: "Added user dashboard",
          tags: ["feature", "ui"],
          project: "project-a",
          timestamp: new Date(Date.now() - 120000).toISOString(), // 2 min ago
        }),
        TestDataFactory.createJournalEntry({
          description: "Authentication system refactor",
          tags: ["refactor", "auth"],
          project: "project-b",
          timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(), // 2 days ago
        }),
      ];

      for (const entry of testEntries) {
        await saveEntry(entry);
      }
    });

    test("should filter entries by days back from current date", async () => {
      const recentEntries = await getRecentEntries({ days: 1 });
      expect(recentEntries).toHaveLength(2); // Only entries from today

      const olderEntries = await getRecentEntries({ days: 3 });
      expect(olderEntries).toHaveLength(3); // All entries
    });

    test("should handle edge case of 0 days (today only)", async () => {
      const todayEntries = await getRecentEntries({ days: 0 });
      expect(todayEntries).toHaveLength(2); // Entries from today
    });

    test("should handle negative days gracefully", async () => {
      const entries = await getRecentEntries({ days: -1 });
      expect(entries).toEqual([]); // Should return empty array
    });

    test("should search in entry descriptions", async () => {
      const authEntries = await searchEntries("auth");
      expect(authEntries).toHaveLength(2); // Two entries mention "auth"

      const bugEntries = await searchEntries("bug");
      expect(bugEntries).toHaveLength(1); // One entry mentions "bug"
    });

    test("should search in tags", async () => {
      const entries = await getRecentEntries({ search: "auth" });
      expect(entries.length).toBeGreaterThan(0);

      const authTaggedEntries = entries.filter(entry =>
        entry.tags?.some(tag => tag.toLowerCase().includes("auth"))
      );
      expect(authTaggedEntries.length).toBeGreaterThan(0);
    });

    test("should search in project names", async () => {
      const projectAEntries = await getRecentEntries({ project: "project-a" });
      expect(projectAEntries).toHaveLength(2);

      const projectBEntries = await getRecentEntries({ project: "project-b" });
      expect(projectBEntries).toHaveLength(1);
    });

    test("should be case insensitive", async () => {
      const upperCaseSearch = await searchEntries("AUTH");
      const lowerCaseSearch = await searchEntries("auth");
      const mixedCaseSearch = await searchEntries("Auth");

      expect(upperCaseSearch).toEqual(lowerCaseSearch);
      expect(lowerCaseSearch).toEqual(mixedCaseSearch);
    });

    test("should handle special regex characters", async () => {
      // Test with characters that have special meaning in regex
      const specialCharSearch = await searchEntries("auth.*bug");
      expect(specialCharSearch).not.toThrow;

      const dotSearch = await searchEntries(".");
      expect(dotSearch).not.toThrow;
    });

    test("should handle empty search terms", async () => {
      const emptySearch = await getRecentEntries({ search: "" });
      const allEntries = await getRecentEntries({});

      expect(emptySearch).toEqual(allEntries);
    });

    test("should apply multiple filters together correctly", async () => {
      const complexFilter = await getRecentEntries({
        days: 3,
        search: "auth",
        project: "project-a",
      });

      expect(complexFilter).toHaveLength(1); // Only the auth bug fix from project-a
      expect(complexFilter[0].description).toContain("authentication bug");
    });
  });

  describe("Statistics Calculation", () => {
    beforeEach(async () => {
      // Create entries with known distribution
      const entries = TestDataFactory.createEntriesWithTimeDistribution(7);
      for (const entry of entries) {
        await saveEntry(entry);
      }
    });

    test("should calculate total entry count correctly", async () => {
      const stats = await getJournalStats();
      expect(stats.totalEntries).toBeGreaterThan(0);
      expect(typeof stats.totalEntries).toBe("number");
    });

    test("should calculate today's entry count", async () => {
      const stats = await getJournalStats();
      expect(stats.todayEntries).toBeGreaterThanOrEqual(0);
      expect(stats.todayEntries).toBeLessThanOrEqual(stats.totalEntries);
    });

    test("should calculate week's entry count", async () => {
      const stats = await getJournalStats();
      expect(stats.weekEntries).toBeGreaterThanOrEqual(stats.todayEntries);
      expect(stats.weekEntries).toBeLessThanOrEqual(stats.totalEntries);
    });

    test("should extract unique project names", async () => {
      const stats = await getJournalStats();
      expect(Array.isArray(stats.projects)).toBe(true);
      expect(new Set(stats.projects).size).toBe(stats.projects.length); // All unique
    });

    test("should handle empty journal for statistics", async () => {
      TestEnvironment.resetJournal();

      const stats = await getJournalStats();
      expect(stats.totalEntries).toBe(0);
      expect(stats.todayEntries).toBe(0);
      expect(stats.weekEntries).toBe(0);
      expect(stats.projects).toEqual([]);
    });
  });

  describe("Performance Requirements", () => {
    test("should load 10,000 entries in under 100ms", async () => {
      // Create and save a large number of entries
      const largeDataset = TestDataFactory.createMultipleEntries(1000); // Reduced for test performance
      for (const entry of largeDataset) {
        await saveEntry(entry);
      }

      const { executionTime } = await PerformanceTester.measureExecution(
        () => readAllEntries(),
        100
      );

      TestAssertions.assertPerformance(executionTime, 100, "Load large dataset");
    });

    test("should search 10,000 entries in under 50ms", async () => {
      // Create searchable dataset
      const searchableEntries = Array.from({ length: 100 }, (_, i) => // Reduced for test speed
        TestDataFactory.createJournalEntry({
          description: i % 10 === 0 ? "special auth entry" : `entry ${i}`,
        })
      );

      for (const entry of searchableEntries) {
        await saveEntry(entry);
      }

      const { executionTime } = await PerformanceTester.measureExecution(
        () => searchEntries("auth"),
        50
      );

      TestAssertions.assertPerformance(executionTime, 50, "Search large dataset");
    });

    test("should not leak memory during repeated operations", async () => {
      const { memoryDelta } = await PerformanceTester.measureMemoryUsage(async () => {
        // Perform many operations
        for (let i = 0; i < 100; i++) {
          const entry = TestDataFactory.createJournalEntry();
          await saveEntry(entry);
          await readAllEntries();
          await getJournalStats();
        }
      });

      // Allow for some memory growth, but not excessive
      TestAssertions.assertMemoryUsage(memoryDelta, 10 * 1024 * 1024, "Repeated operations"); // 10MB limit
    });
  });
});

describe("Journal Operations - Error Handling", () => {
  test("should recover from corrupted JSONL files", async () => {
    const validEntries = TestDataFactory.createMultipleEntries(5);
    const corruptedContent = ErrorTester.createCorruptedJSONL(validEntries);

    writeFileSync(getJournalPath(), corruptedContent);

    const recoveredEntries = await readAllEntries();

    // Should recover some entries without crashing
    expect(recoveredEntries.length).toBeGreaterThan(0);
    expect(recoveredEntries.length).toBeLessThanOrEqual(validEntries.length);

    // All recovered entries should be valid
    recoveredEntries.forEach(entry => {
      expect(entry.id).toBeDefined();
      expect(entry.type).toBe("checkpoint");
      expect(entry.timestamp).toBeDefined();
    });
  });

  test("should provide helpful error messages", async () => {
    // This test would check error message quality
    // Implementation depends on adding proper error handling to the journal module
  });

  test("should never crash on invalid input", async () => {
    const invalidInputs = [
      null,
      undefined,
      {},
      { invalid: "structure" },
      "",
      123,
      [],
    ];

    for (const input of invalidInputs) {
      await expect(saveEntry(input as any)).rejects.toThrow();
      // Should throw error, not crash
    }
  });
});